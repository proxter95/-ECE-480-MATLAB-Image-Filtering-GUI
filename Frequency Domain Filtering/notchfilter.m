function H = notchfilter(type, notch, M, N, C, D0, n)
%NOTCHFILTER Generates notch filter transfer fucntions
%   H = NOTCHFILTER(TYPE, NOTCH, M, N, C, D0, n) generates a nothc transfer
%   function of size MxN. C is Kx2 matrix, each row of which contains the
%   (u,v) coordinates in the frequency domain, of the center of one notch.
%   The corresponding symmetric notch pair is generated automatically by
%   the function. The notch coordinates are with respect to the standard
%   origin, at the top left of the transform. The function generates them
%   with respect to the center of teh frequency rectangle automatically.
%   Each pair of coordinates, (u,v), gives the location of one notch. D0 is
%   the radius (cut-off frequency) of the notches. It can be specified as a
%   scalar, in which case it is used in all K notch pairs, or it ca be a
%   vector of length K, containing an individual cutoff value for each
%   notch pair. n is the order of the Butterworth transfer function if one
%   is specified. 
% 
%   CAUTION: It is possible that the Centers of the notches generated by
%   this function may exceed the bounds of the fft of the image to be
%   filtered. It is for this reason that the values within the C array
%   should not exceed half of the padded array dimensions used by DFTFILT.
%   If the notches exceed the bounds of the padded images, the filtering
%   may not have the desired effect. Use the function SHOWFFTPLOTS(F, H) to
%   verify the position(s) of the notches. 
% 
%   Valid values of TYPE are:
%       
%       'ideal'         Ideal notch filter transfer function. n is not
%                       used.
%   
%       'butterworth'   Butterworth notch filter transfer function of order
%                       n. The default value of n is 1.
% 
%       'gaussian'      Gaussian notch filter transfer function. n is not
%                       used.
% 
%   Valid values of NOTCH are:
%         
%       'reject'        Notchreject transfer function.
% 
%       'pass'          Notchpass transfer function. 
% 
%   One of these two values must be specified.
% 
%   H is of class double. It is returned uncentered for consistency with
%   the function dftfilt. To view H as an image or mesh plot, it should be
%   centered using Hc = fftshift(H).

%default value for n set to 1.
if nargin < 7 || all(n) || n <= 0
    n = 1;
end

[U, V] = dftuv(M, N); %Set up meshgrid

k = size(C); %Number of Center pairs
%Initialize empty arrays for Distance Values
Dk_pos = double.empty;
Dk_neg = double.empty;

%Calculate distances according to coordinates of notch centers
%Save results by appending in Dk_pos and Dk_neg arrays
for i = 1:k(1)
    D_pos = (((U - C(i,1)).^2) + ((V - C(i,2)).^2)).^0.5;
%     D_pos = (((U - M/2 - C(i,1)).^2) + ((V - N/2 - C(i,2)).^2)).^0.5;
%     BOTTOM ONE IS BAD. DON'T USE!!!!
    Dk_pos = cat(3, Dk_pos, D_pos);

    D_neg = (((U + C(i,1)).^2) + ((V + C(i,2)).^2)).^0.5;
%     D_neg = (((U - M/2 + C(i,1)).^2) + ((V - N/2 + C(i,2)).^2)).^0.5;
%     BOTTOM ONE IS BAD. DON'T USE!!!!
    Dk_neg = cat(3, Dk_neg, D_neg);
end

%Initialize empty arrays for Transfer Functions
H_pos = double.empty;
H_neg = double.empty;
H_all = double.empty;

switch type
    case 'ideal'
        if isscalar(D0)
            for i = 1:k(1)
                H = idealReject(D0,Dk_pos(:,:,i));
                H_pos = cat(3, H_pos, H);
                H = idealReject(D0,Dk_neg(:,:,i));
                H_neg = cat(3, H_neg, H);
            end
        else
            for i = 1:k(1)
                H = idealReject(D0(i),Dk_pos(:,:,i));
                H_pos = cat(3, H_pos, H);
                H = idealReject(D0(i),Dk_neg(:,:,i));
                H_neg = cat(3, H_neg, H);
            end
        end
    case 'butterworth'
        if isscalar(D0)
            for i = 1:k(1)
                H = butterworthReject(D0,Dk_pos(:,:,i),n);
                H_pos = cat(3, H_pos, H);
                H = butterworthReject(D0,Dk_neg(:,:,i),n);
                H_neg = cat(3, H_neg, H);
            end
        else
            for i = 1:k(1)
                H = butterworthReject(D0(i),Dk_pos(:,:,i),n);
                H_pos = cat(3, H_pos, H);
                H = butterworthReject(D0(i),Dk_neg(:,:,i),n);
                H_neg = cat(3, H_neg, H);
            end
        end
    case 'gaussian'
        if isscalar(D0)
            for i = 1:k(1)
                H = gaussianReject(D0,Dk_pos(:,:,i));
                H_pos = cat(3, H_pos, H);
                H = gaussianReject(D0,Dk_neg(:,:,i));
                H_neg = cat(3, H_neg, H);
            end
        else
            for i = 1:k(1)
                H = gaussianReject(D0(i),Dk_pos(:,:,i));
                H_pos = cat(3, H_pos, H);
                H = gaussianReject(D0(i),Dk_neg(:,:,i));
                H_neg = cat(3, H_neg, H);
            end
        end
    otherwise
        error('Unknown filter type.')
end

for i = 1:k(1)
    H_prod = H_pos(:,:,i).*H_neg(:,:,i);
    H_all = cat(3,H_all,H_prod);
end

H = double.empty;
for i = 1:k(1)
    if i == 1
        H = H_all(:,:,i);
    else
        H = H.*H_all(:,:,i);
    end
end

%%OLD CODE saved for reference
% switch type
%     case 'ideal'
%         if isscalar(D0)
%             for i = 1:k(1)
%                 Hi = idealReject(D0,Dk_pos(:,:,i)).*idealReject(D0,Dk_neg(:,:,i));
%                 if i == 1
%                     H = Hi;
%                 else
%                     H = H.*Hi;
%                 end
%             end
%         else
%             for i = 1:k(1)
%                 Hi = idealReject(D0(i),Dk_pos(:,:,i)).*idealReject(D0(i),Dk_neg(:,:,i));
%                 if i == 1
%                     H = Hi;
%                 else
%                     H = H.*Hi;
%                 end
%             end
%         end
%     case 'butterworth'
%         if isscalar(D0)
%             for i = 1:k(1)
%                 Hi = butterworthReject(D0,Dk_pos(:,:,i),n).*butterworthReject(D0,Dk_neg(:,:,i),n);
%                 if i == 1
%                     H = Hi;
%                 else
%                     H = H.*Hi;
%                 end
%             end
%         else
%             for i = 1:k(1)
%                 Hi = buttwerworthReject(D0(i),Dk_pos(:,:,i),n).*butterworthReject(D0(i),Dk_neg(:,:,i),n);
%                 if i == 1
%                     H = Hi;
%                 else
%                     H = H.*Hi;
%                 end
%             end
%         end
%     case 'gaussian'
%         if isscalar(D0)
%             for i = 1:k(1)
%                 Hi = gaussianReject(D0,Dk_pos(:,:,i)).*gaussianReject(D0,Dk_neg(:,:,i));
%                 if i == 1
%                     H = Hi;
%                 else
%                     H = H.*Hi;
%                 end
%             end
%         else
%             for i = 1:k(1)
%                 Hi = gaussianReject(D0(i),Dk_pos(:,:,i)).*gaussianReject(D0(i),Dk_neg(:,:,i));
%                 if i == 1
%                     H = Hi;
%                 else
%                     H = H.*Hi;
%                 end
%             end
%         end
%     otherwise
%         error('Unknown filter type.')
% end

if isequal(notch, 'pass')
    H = 1 - H;
end

    function H = idealReject(D0, D)
        H = double(D <= D0);    %Ideal lowpass
        H = 1 - H;              %Convert to Highpass
    end

    function H = butterworthReject(D0, D, n)
        H = 1./(1 + (D0./D).^(2*n));
    end
    
    function H = gaussianReject(D0, D)
       H = 1- exp(-(D.^2)./(2*(D0.^2)));
    end
end